// Code generated by protoc-gen-mgorm. DO NOT EDIT.
package configcenter

import (
	"context"
	"fmt"
	"time"

	"github.com/995933447/mgorm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

const (
	ConfigSchemaDbName   = "mconfigcenter"
	ConfigSchemaTbName   = "config_schema"
	ConfigSchemaConnName = "mconfigcenter"
)

// 索引
var configSchemaIndexKeys = []string{}

var configSchemaUniqueIndexKeys = []string{
	"coll_name",
}

var configSchemaExpireIndexKeys = []string{}

type ConfigSchemaOrm struct {
	ID            primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	CollName      string             `json:"coll_name" bson:"coll_name"`
	IndexKeys     []string           `json:"index_keys" bson:"index_keys"`
	UniqIndexKeys []string           `json:"uniq_index_keys" bson:"uniq_index_keys"`
	JsonSchema    string             `json:"json_schema" bson:"json_schema"`
	CreatedAt     time.Time          `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt     time.Time          `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var configSchemaOrmCache mgorm.Cache

func SetConfigSchemaOrmCache(cache mgorm.Cache) {
	configSchemaOrmCache = cache
}

var onConfigSchemaOrmQueryDone mgorm.OnQueryDoneFunc

func SetConfigSchemaOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onConfigSchemaOrmQueryDone = fn
}

func NewConfigSchemaModel() *ConfigSchemaModel {
	cache := configSchemaOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		ConfigSchemaConnName,
		ConfigSchemaDbName,
		ConfigSchemaTbName,
		false,
		cache,
		configSchemaIndexKeys,
		configSchemaUniqueIndexKeys,
		configSchemaExpireIndexKeys,
	)
	onQueryDoneFunc := onConfigSchemaOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &ConfigSchemaModel{
		Model: mgorm.Model[ConfigSchemaOrm]{
			Orm:    orm,
			Cached: false,
		},
	}
}

type ConfigSchemaModel struct {
	mgorm.Model[ConfigSchemaOrm]
}

func (m *ConfigSchemaModel) NormalizeOrmForInsert(data *ConfigSchemaOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *ConfigSchemaModel) InsertOneIgnoreConflict(ctx context.Context, data *ConfigSchemaOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *ConfigSchemaModel) InsertOne(ctx context.Context, data *ConfigSchemaOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *ConfigSchemaModel) InsertMany(ctx context.Context, dataList []*ConfigSchemaOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *ConfigSchemaModel) GetCacheKeys(data *ConfigSchemaOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"coll_name:%s", data.CollName,
	))
	return cacheKeys
}

func (m *ConfigSchemaModel) Update(ctx context.Context, data *ConfigSchemaOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *ConfigSchemaModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *ConfigSchemaModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *ConfigSchemaModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *ConfigSchemaModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *ConfigSchemaModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *ConfigSchemaModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteOne(ctx, filter)
}

func (m *ConfigSchemaModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteMany(ctx, filter)
}

func (m *ConfigSchemaModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *ConfigSchemaModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *ConfigSchemaModel) FindOneByID(ctx context.Context, id string) (*ConfigSchemaOrm, error) {
	var data ConfigSchemaOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *ConfigSchemaModel) UpdateOneByCollName(ctx context.Context, collName string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data ConfigSchemaOrm
	filter["coll_name"] = collName
	cacheKey := fmt.Sprintf(
		"coll_name:%s",
		collName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *ConfigSchemaModel) FindOneByCollName(ctx context.Context, collName string) (*ConfigSchemaOrm, error) {
	var data ConfigSchemaOrm
	filter := bson.M{}
	filter["coll_name"] = collName
	cacheKey := fmt.Sprintf(
		"coll_name:%s",
		collName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *ConfigSchemaModel) DeleteOneByCollName(ctx context.Context, collName string) (*mongo.DeleteResult, error) {
	var data ConfigSchemaOrm
	filter := bson.M{}
	filter["coll_name"] = collName
	cacheKey := fmt.Sprintf(
		"coll_name:%s",
		collName,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}
